"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[7385],{8453:(e,t,s)=>{s.d(t,{RP:()=>i});var r=s(6540);const n=r.createContext({});function i(e){const t=r.useContext(n);return r.useMemo(()=>"function"==typeof e?e(t):{...t,...e},[t,e])}},9427:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=s(4848),n=s(8453);const i={},o="Testing Guide",a={id:"capstone/testing-guide",title:"Testing Guide",description:"Overview",source:"@site/docs/capstone/testing-guide.md",sourceDirName:"capstone",slug:"/capstone/testing-guide",permalink:"/humanoid-robotics-book/capstone/testing-guide",draft:!1,unlisted:!1,editUrl:"https://github.com/ArifAbbas11/humanoid-robotics-book/tree/main/docs/capstone/testing-guide.md",tags:[],version:"current",frontMatter:{},sidebar:"bookSidebar",previous:{title:"Integration Guide",permalink:"/humanoid-robotics-book/capstone/integration-guide"},next:{title:"Troubleshooting",permalink:"/humanoid-robotics-book/capstone/troubleshooting"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Testing Philosophy",id:"testing-philosophy",level:2},{value:"Testing Pyramid for Robotics",id:"testing-pyramid-for-robotics",level:3},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Testing Individual Functions",id:"testing-individual-functions",level:3},{value:"Testing ROS 2 Components",id:"testing-ros-2-components",level:3},{value:"Component Testing",id:"component-testing",level:2},{value:"Testing Individual Robot Subsystems",id:"testing-individual-robot-subsystems",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"Testing Component Interactions",id:"testing-component-interactions",level:3},{value:"System Testing",id:"system-testing",level:2},{value:"End-to-End System Tests",id:"end-to-end-system-tests",level:3},{value:"Simulation Testing",id:"simulation-testing",level:2},{value:"Gazebo Integration Tests",id:"gazebo-integration-tests",level:3},{value:"Performance Testing",id:"performance-testing",level:2},{value:"Load and Stress Testing",id:"load-and-stress-testing",level:3},{value:"Safety Testing",id:"safety-testing",level:2},{value:"Safety Validation Tests",id:"safety-validation-tests",level:3},{value:"Regression Testing",id:"regression-testing",level:2},{value:"Automated Test Suite",id:"automated-test-suite",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:2},{value:"Test Organization and Management",id:"test-organization-and-management",level:3},{value:"Continuous Testing",id:"continuous-testing",level:2},{value:"Automated Testing Pipeline",id:"automated-testing-pipeline",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.RP)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"testing-guide",children:"Testing Guide"}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"Testing is critical for ensuring the reliability, safety, and performance of humanoid robot systems. This guide covers comprehensive testing strategies for all aspects of your integrated robot system, from unit-level components to end-to-end system validation."}),"\n",(0,r.jsx)(t.h2,{id:"testing-philosophy",children:"Testing Philosophy"}),"\n",(0,r.jsx)(t.h3,{id:"testing-pyramid-for-robotics",children:"Testing Pyramid for Robotics"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"        System Testing (10%)\r\n           \u2193\r\n    Integration Testing (20%)\r\n           \u2193\r\n     Component Testing (70%)\n"})}),"\n",(0,r.jsx)(t.p,{children:"In robotics, the traditional testing pyramid is adapted to account for the unique challenges of physical systems:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Unit Testing"}),": Test individual functions and algorithms"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Component Testing"}),": Test individual robot subsystems"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Integration Testing"}),": Test interactions between components"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"System Testing"}),": Test the complete robot system"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Field Testing"}),": Test in real-world environments"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,r.jsx)(t.h3,{id:"testing-individual-functions",children:"Testing Individual Functions"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'import unittest\r\nimport numpy as np\r\nfrom geometry_msgs.msg import Point, Pose\r\nfrom tf2_ros import TransformException\r\n\r\nclass TestGeometryFunctions(unittest.TestCase):\r\n    def test_pose_to_matrix_conversion(self):\r\n        """Test conversion between Pose message and transformation matrix"""\r\n        from geometry_utils import pose_to_matrix, matrix_to_pose\r\n\r\n        # Create test pose\r\n        test_pose = Pose()\r\n        test_pose.position.x = 1.0\r\n        test_pose.position.y = 2.0\r\n        test_pose.position.z = 3.0\r\n        test_pose.orientation.w = 1.0\r\n        test_pose.orientation.x = 0.0\r\n        test_pose.orientation.y = 0.0\r\n        test_pose.orientation.z = 0.0\r\n\r\n        # Convert to matrix and back\r\n        matrix = pose_to_matrix(test_pose)\r\n        recovered_pose = matrix_to_pose(matrix)\r\n\r\n        # Verify conversion accuracy\r\n        self.assertAlmostEqual(test_pose.position.x, recovered_pose.position.x, places=5)\r\n        self.assertAlmostEqual(test_pose.position.y, recovered_pose.position.y, places=5)\r\n        self.assertAlmostEqual(test_pose.position.z, recovered_pose.position.z, places=5)\r\n\r\n    def test_distance_calculation(self):\r\n        """Test distance calculation between points"""\r\n        from navigation_utils import calculate_distance\r\n\r\n        point1 = Point(x=0.0, y=0.0, z=0.0)\r\n        point2 = Point(x=3.0, y=4.0, z=0.0)\r\n\r\n        distance = calculate_distance(point1, point2)\r\n        expected_distance = 5.0  # 3-4-5 triangle\r\n\r\n        self.assertAlmostEqual(distance, expected_distance, places=5)\r\n\r\nclass TestControlAlgorithms(unittest.TestCase):\r\n    def test_pid_controller(self):\r\n        """Test PID controller behavior"""\r\n        from control_algorithms import PIDController\r\n\r\n        pid = PIDController(kp=1.0, ki=0.1, kd=0.01)\r\n\r\n        # Test with zero error\r\n        output = pid.compute(0.0, 0.0, 0.1)  # error=0, dt=0.1\r\n        self.assertEqual(output, 0.0)\r\n\r\n        # Test with positive error\r\n        output = pid.compute(1.0, 0.0, 0.1)  # error=1.0\r\n        self.assertGreater(output, 0.0)\r\n\r\n        # Test with negative error\r\n        output = pid.compute(-1.0, 0.0, 0.1)  # error=-1.0\r\n        self.assertLess(output, 0.0)\n'})}),"\n",(0,r.jsx)(t.h3,{id:"testing-ros-2-components",children:"Testing ROS 2 Components"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"import unittest\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom sensor_msgs.msg import Image\r\nfrom geometry_msgs.msg import Twist\r\nfrom rclpy.qos import QoSProfile\r\nfrom rclpy.executors import SingleThreadedExecutor\r\nimport threading\r\n\r\nclass TestROSNode(unittest.TestCase):\r\n    @classmethod\r\n    def setUpClass(cls):\r\n        rclpy.init()\r\n\r\n    @classmethod\r\n    def tearDownClass(cls):\r\n        rclpy.shutdown()\r\n\r\n    def test_simple_publisher_subscriber(self):\r\n        \"\"\"Test basic publisher-subscriber communication\"\"\"\r\n        class TestPublisher(Node):\r\n            def __init__(self):\r\n                super().__init__('test_publisher')\r\n                self.publisher = self.create_publisher(String, 'test_topic', 10)\r\n\r\n            def publish_message(self, msg):\r\n                string_msg = String()\r\n                string_msg.data = msg\r\n                self.publisher.publish(string_msg)\r\n\r\n        class TestSubscriber(Node):\r\n            def __init__(self):\r\n                super().__init__('test_subscriber')\r\n                self.received_messages = []\r\n                self.subscription = self.create_subscription(\r\n                    String, 'test_topic', self.listener_callback, 10)\r\n\r\n            def listener_callback(self, msg):\r\n                self.received_messages.append(msg.data)\r\n\r\n        # Create nodes\r\n        publisher_node = TestPublisher()\r\n        subscriber_node = TestSubscriber()\r\n\r\n        # Create executor and add nodes\r\n        executor = SingleThreadedExecutor()\r\n        executor.add_node(publisher_node)\r\n        executor.add_node(subscriber_node)\r\n\r\n        # Start executor in a separate thread\r\n        executor_thread = threading.Thread(target=executor.spin)\r\n        executor_thread.start()\r\n\r\n        # Publish and verify message\r\n        test_message = \"Hello, ROS!\"\r\n        publisher_node.publish_message(test_message)\r\n\r\n        # Wait for message to be received\r\n        import time\r\n        time.sleep(0.5)\r\n\r\n        # Stop executor\r\n        executor.shutdown()\r\n        executor_thread.join()\r\n\r\n        # Verify message was received\r\n        self.assertEqual(len(subscriber_node.received_messages), 1)\r\n        self.assertEqual(subscriber_node.received_messages[0], test_message)\n"})}),"\n",(0,r.jsx)(t.h2,{id:"component-testing",children:"Component Testing"}),"\n",(0,r.jsx)(t.h3,{id:"testing-individual-robot-subsystems",children:"Testing Individual Robot Subsystems"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'class TestNavigationComponent(unittest.TestCase):\r\n    def setUp(self):\r\n        self.navigation_system = NavigationSystem()\r\n        self.test_map = self.create_test_map()\r\n\r\n    def create_test_map(self):\r\n        """Create a simple test map for navigation testing"""\r\n        # Create a 10x10 grid map with some obstacles\r\n        test_map = np.zeros((10, 10), dtype=np.uint8)\r\n        # Add some obstacles\r\n        test_map[5, 2:8] = 255  # Horizontal obstacle\r\n        test_map[2:8, 5] = 255  # Vertical obstacle\r\n        return test_map\r\n\r\n    def test_path_planning(self):\r\n        """Test path planning in simple environment"""\r\n        start = (1, 1)\r\n        goal = (8, 8)\r\n\r\n        path = self.navigation_system.plan_path(start, goal, self.test_map)\r\n\r\n        # Verify path exists and is valid\r\n        self.assertIsNotNone(path)\r\n        self.assertGreater(len(path), 0)\r\n\r\n        # Verify path starts and ends at correct locations\r\n        self.assertEqual(path[0], start)\r\n        self.assertEqual(path[-1], goal)\r\n\r\n        # Verify path doesn\'t go through obstacles\r\n        for point in path:\r\n            self.assertEqual(self.test_map[point], 0)  # 0 = free space\r\n\r\n    def test_obstacle_avoidance(self):\r\n        """Test obstacle avoidance behavior"""\r\n        # Create a scenario where robot must avoid obstacles\r\n        start = (1, 1)\r\n        goal = (8, 8)\r\n\r\n        path = self.navigation_system.plan_path(start, goal, self.test_map)\r\n\r\n        # Path should go around obstacles, not through them\r\n        # This is a basic check - more sophisticated validation needed\r\n        self.assertTrue(self.path_avoids_obstacles(path, self.test_map))\r\n\r\n    def path_avoids_obstacles(self, path, map_data):\r\n        """Check if path avoids obstacles"""\r\n        for point in path:\r\n            if map_data[point] > 0:  # Obstacle\r\n                return False\r\n        return True\r\n\r\nclass TestManipulationComponent(unittest.TestCase):\r\n    def setUp(self):\r\n        self.manipulator = ManipulationSystem()\r\n        self.test_objects = self.create_test_objects()\r\n\r\n    def create_test_objects(self):\r\n        """Create test objects for manipulation"""\r\n        return [\r\n            {\'name\': \'cup\', \'pose\': (1.0, 0.5, 0.8), \'size\': (0.1, 0.1, 0.1)},\r\n            {\'name\': \'box\', \'pose\': (1.2, 0.7, 0.8), \'size\': (0.2, 0.2, 0.2)}\r\n        ]\r\n\r\n    def test_grasp_planning(self):\r\n        """Test grasp planning for objects"""\r\n        for obj in self.test_objects:\r\n            grasp_poses = self.manipulator.plan_grasps(obj)\r\n\r\n            # Verify grasps are generated\r\n            self.assertGreater(len(grasp_poses), 0)\r\n\r\n            # Verify grasp poses are valid (not None)\r\n            for grasp in grasp_poses:\r\n                self.assertIsNotNone(grasp)\r\n\r\n    def test_reachability_check(self):\r\n        """Test reachability of objects"""\r\n        for obj in self.test_objects:\r\n            is_reachable = self.manipulator.is_reachable(obj[\'pose\'])\r\n\r\n            # Basic reachability should return boolean\r\n            self.assertIsInstance(is_reachable, bool)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(t.h3,{id:"testing-component-interactions",children:"Testing Component Interactions"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"class TestPerceptionNavigationIntegration(unittest.TestCase):\r\n    def setUp(self):\r\n        self.perception_system = PerceptionSystem()\r\n        self.navigation_system = NavigationSystem()\r\n        self.integration_layer = PerceptionNavigationIntegration(\r\n            self.perception_system,\r\n            self.navigation_system\r\n        )\r\n\r\n    def test_object_guided_navigation(self):\r\n        \"\"\"Test navigation to detected objects\"\"\"\r\n        # Simulate object detection\r\n        detected_objects = [\r\n            {'name': 'target', 'pose': (5.0, 5.0, 0.0), 'confidence': 0.9}\r\n        ]\r\n\r\n        # Process detection and generate navigation goal\r\n        navigation_goal = self.integration_layer.process_object_detection(\r\n            detected_objects\r\n        )\r\n\r\n        # Verify navigation goal is generated correctly\r\n        self.assertIsNotNone(navigation_goal)\r\n        self.assertEqual(navigation_goal.target_pose.position.x, 5.0)\r\n        self.assertEqual(navigation_goal.target_pose.position.y, 5.0)\r\n\r\n    def test_dynamic_obstacle_avoidance(self):\r\n        \"\"\"Test navigation with dynamic obstacle detection\"\"\"\r\n        # Set up initial conditions\r\n        start_pose = (0.0, 0.0, 0.0)\r\n        goal_pose = (10.0, 10.0, 0.0)\r\n\r\n        # Plan initial path\r\n        initial_path = self.navigation_system.plan_path(start_pose, goal_pose)\r\n\r\n        # Simulate dynamic obstacle appearing\r\n        dynamic_obstacle = {'pose': (5.0, 5.0, 0.0), 'radius': 1.0}\r\n\r\n        # Update navigation with obstacle information\r\n        updated_path = self.integration_layer.update_path_with_obstacle(\r\n            initial_path, dynamic_obstacle\r\n        )\r\n\r\n        # Verify path was updated to avoid obstacle\r\n        self.assertNotEqual(len(initial_path), len(updated_path))\r\n        # Additional validation would check that path avoids obstacle\r\n\r\nclass TestVLAIntegration(unittest.TestCase):\r\n    def setUp(self):\r\n        self.voice_recognition = VoiceRecognitionSystem()\r\n        self.language_understanding = LanguageUnderstandingSystem()\r\n        self.action_execution = ActionExecutionSystem()\r\n        self.vla_integration = VLAIntegration(\r\n            self.voice_recognition,\r\n            self.language_understanding,\r\n            self.action_execution\r\n        )\r\n\r\n    def test_voice_command_to_action(self):\r\n        \"\"\"Test complete VLA pipeline\"\"\"\r\n        # Simulate voice command\r\n        voice_input = \"Go to the kitchen and pick up the red cup\"\r\n\r\n        # Process through VLA pipeline\r\n        result = self.vla_integration.process_command(voice_input)\r\n\r\n        # Verify pipeline processed correctly\r\n        self.assertIsNotNone(result)\r\n        self.assertTrue(result['success'])\r\n        self.assertIn('navigation', result['actions'])\r\n        self.assertIn('manipulation', result['actions'])\n"})}),"\n",(0,r.jsx)(t.h2,{id:"system-testing",children:"System Testing"}),"\n",(0,r.jsx)(t.h3,{id:"end-to-end-system-tests",children:"End-to-End System Tests"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"class TestCompleteRobotSystem(unittest.TestCase):\r\n    def setUp(self):\r\n        # Set up complete robot system\r\n        self.robot_system = CompleteRobotSystem()\r\n        self.test_scenarios = self.load_test_scenarios()\r\n\r\n    def load_test_scenarios(self):\r\n        \"\"\"Load various test scenarios\"\"\"\r\n        return [\r\n            {\r\n                'name': 'simple_navigation',\r\n                'commands': ['go to kitchen'],\r\n                'expected_outcomes': ['navigation_success']\r\n            },\r\n            {\r\n                'name': 'object_interaction',\r\n                'commands': ['find red cup', 'pick up red cup', 'place cup on table'],\r\n                'expected_outcomes': ['detection_success', 'grasp_success', 'placement_success']\r\n            },\r\n            {\r\n                'name': 'complex_task',\r\n                'commands': ['go to kitchen', 'find ingredients', 'bring to counter'],\r\n                'expected_outcomes': ['multiple_successes']\r\n            }\r\n        ]\r\n\r\n    def test_scenario_execution(self):\r\n        \"\"\"Test execution of various scenarios\"\"\"\r\n        for scenario in self.test_scenarios:\r\n            with self.subTest(scenario=scenario['name']):\r\n                # Execute scenario\r\n                results = self.execute_scenario(scenario)\r\n\r\n                # Verify expected outcomes\r\n                for expected_outcome in scenario['expected_outcomes']:\r\n                    self.assertIn(expected_outcome, results)\r\n\r\n    def execute_scenario(self, scenario):\r\n        \"\"\"Execute a test scenario and return results\"\"\"\r\n        results = []\r\n\r\n        for command in scenario['commands']:\r\n            try:\r\n                result = self.robot_system.execute_command(command)\r\n                results.append(result['status'])\r\n            except Exception as e:\r\n                results.append(f'error: {str(e)}')\r\n\r\n        return results\r\n\r\n    def test_system_stress(self):\r\n        \"\"\"Test system under stress conditions\"\"\"\r\n        # Test with rapid command succession\r\n        commands = ['go to kitchen'] * 10\r\n\r\n        start_time = time.time()\r\n        for command in commands:\r\n            self.robot_system.execute_command(command)\r\n        end_time = time.time()\r\n\r\n        # Verify system can handle rapid commands within time constraints\r\n        execution_time = end_time - start_time\r\n        self.assertLess(execution_time, 30.0)  # Should complete in under 30 seconds\r\n\r\n    def test_failure_recovery(self):\r\n        \"\"\"Test system recovery from failures\"\"\"\r\n        # Simulate a component failure\r\n        self.robot_system.navigation_system.force_failure()\r\n\r\n        # Try to execute navigation command\r\n        result = self.robot_system.execute_command('go to kitchen')\r\n\r\n        # Verify system handles failure gracefully\r\n        self.assertIn('recovery', result['actions'])\r\n        self.assertEqual(result['status'], 'recovered')\n"})}),"\n",(0,r.jsx)(t.h2,{id:"simulation-testing",children:"Simulation Testing"}),"\n",(0,r.jsx)(t.h3,{id:"gazebo-integration-tests",children:"Gazebo Integration Tests"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'import unittest\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import LaserScan, Image\r\nfrom gazebo_msgs.srv import SpawnEntity, DeleteEntity\r\nfrom std_srvs.srv import Empty\r\nimport time\r\n\r\nclass TestSimulationIntegration(unittest.TestCase):\r\n    @classmethod\r\n    def setUpClass(cls):\r\n        rclpy.init()\r\n\r\n    @classmethod\r\n    def tearDownClass(cls):\r\n        rclpy.shutdown()\r\n\r\n    def setUp(self):\r\n        self.node = Node(\'simulation_tester\')\r\n\r\n        # Create publishers for robot control\r\n        self.cmd_vel_pub = self.node.create_publisher(\r\n            Twist, \'/cmd_vel\', 10\r\n        )\r\n\r\n        # Create subscribers for sensor data\r\n        self.laser_sub = self.node.create_subscription(\r\n            LaserScan, \'/scan\', self.laser_callback, 10\r\n        )\r\n        self.camera_sub = self.node.create_subscription(\r\n            Image, \'/camera/image_raw\', self.camera_callback, 10\r\n        )\r\n\r\n        # Store sensor data\r\n        self.latest_laser = None\r\n        self.latest_image = None\r\n\r\n    def laser_callback(self, msg):\r\n        self.latest_laser = msg\r\n\r\n    def camera_callback(self, msg):\r\n        self.latest_image = msg\r\n\r\n    def test_sensor_data_availability(self):\r\n        """Test that sensor data is available in simulation"""\r\n        # Wait for sensor data\r\n        timeout = 5.0  # seconds\r\n        start_time = time.time()\r\n\r\n        while (self.latest_laser is None or self.latest_image is None) and \\\r\n              (time.time() - start_time < timeout):\r\n            rclpy.spin_once(self.node, timeout_sec=0.1)\r\n\r\n        # Verify data was received\r\n        self.assertIsNotNone(self.latest_laser, "Laser data not received")\r\n        self.assertIsNotNone(self.latest_image, "Camera data not received")\r\n\r\n    def test_robot_movement(self):\r\n        """Test robot movement in simulation"""\r\n        # Send movement command\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.5  # Move forward at 0.5 m/s\r\n        cmd.angular.z = 0.0  # No rotation\r\n\r\n        # Publish command\r\n        self.cmd_vel_pub.publish(cmd)\r\n\r\n        # Wait and verify movement affects sensor readings\r\n        time.sleep(2.0)  # Allow time for movement\r\n\r\n        # In a real test, you would verify that position changed\r\n        # or that laser readings changed appropriately\r\n        self.assertIsNotNone(self.latest_laser)\r\n\r\n    def test_obstacle_detection(self):\r\n        """Test obstacle detection in simulation"""\r\n        # Wait for sensor data\r\n        timeout = 5.0\r\n        start_time = time.time()\r\n\r\n        while self.latest_laser is None and (time.time() - start_time < timeout):\r\n            rclpy.spin_once(self.node, timeout_sec=0.1)\r\n\r\n        if self.latest_laser:\r\n            # Check that there are valid range readings\r\n            valid_ranges = [r for r in self.latest_laser.ranges if r > 0 and r < float(\'inf\')]\r\n            self.assertGreater(len(valid_ranges), 0, "No valid laser readings")\n'})}),"\n",(0,r.jsx)(t.h2,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,r.jsx)(t.h3,{id:"load-and-stress-testing",children:"Load and Stress Testing"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"import time\r\nimport threading\r\nimport psutil\r\nfrom concurrent.futures import ThreadPoolExecutor\r\nimport statistics\r\n\r\nclass PerformanceTester:\r\n    def __init__(self, robot_system):\r\n        self.robot_system = robot_system\r\n        self.metrics = {\r\n            'response_times': [],\r\n            'throughput': [],\r\n            'cpu_usage': [],\r\n            'memory_usage': [],\r\n            'success_rates': []\r\n        }\r\n\r\n    def test_concurrent_commands(self, num_commands=10):\r\n        \"\"\"Test system performance with concurrent commands\"\"\"\r\n        start_time = time.time()\r\n\r\n        def send_command(i):\r\n            command = f\"command_{i}\"\r\n            start_cmd = time.time()\r\n            try:\r\n                result = self.robot_system.execute_command(command)\r\n                response_time = time.time() - start_cmd\r\n                return {'success': True, 'response_time': response_time, 'result': result}\r\n            except Exception as e:\r\n                response_time = time.time() - start_cmd\r\n                return {'success': False, 'response_time': response_time, 'error': str(e)}\r\n\r\n        # Execute commands concurrently\r\n        with ThreadPoolExecutor(max_workers=num_commands) as executor:\r\n            futures = [executor.submit(send_command, i) for i in range(num_commands)]\r\n            results = [future.result() for future in futures]\r\n\r\n        end_time = time.time()\r\n        total_time = end_time - start_time\r\n\r\n        # Calculate metrics\r\n        successful_commands = [r for r in results if r['success']]\r\n        response_times = [r['response_time'] for r in results]\r\n\r\n        metrics = {\r\n            'total_commands': num_commands,\r\n            'successful_commands': len(successful_commands),\r\n            'success_rate': len(successful_commands) / num_commands,\r\n            'total_time': total_time,\r\n            'throughput': num_commands / total_time,\r\n            'avg_response_time': statistics.mean(response_times) if response_times else 0,\r\n            'max_response_time': max(response_times) if response_times else 0,\r\n            'min_response_time': min(response_times) if response_times else 0\r\n        }\r\n\r\n        return metrics\r\n\r\n    def test_long_running_stability(self, duration_minutes=10):\r\n        \"\"\"Test system stability over extended period\"\"\"\r\n        start_time = time.time()\r\n        end_time = start_time + (duration_minutes * 60)  # Convert to seconds\r\n\r\n        command_counter = 0\r\n        successful_commands = 0\r\n\r\n        while time.time() < end_time:\r\n            try:\r\n                # Send periodic commands to keep system active\r\n                result = self.robot_system.execute_command(f\"status_check_{command_counter}\")\r\n                if result.get('success', False):\r\n                    successful_commands += 1\r\n            except:\r\n                pass  # Command failed, continue testing\r\n\r\n            command_counter += 1\r\n\r\n            # Record system metrics periodically\r\n            if command_counter % 10 == 0:\r\n                self.record_system_metrics()\r\n\r\n            time.sleep(1)  # Send command every second\r\n\r\n        # Calculate stability metrics\r\n        total_commands = command_counter\r\n        success_rate = successful_commands / total_commands if total_commands > 0 else 0\r\n\r\n        return {\r\n            'total_duration': duration_minutes,\r\n            'total_commands': total_commands,\r\n            'successful_commands': successful_commands,\r\n            'success_rate': success_rate,\r\n            'avg_commands_per_minute': total_commands / duration_minutes\r\n        }\r\n\r\n    def record_system_metrics(self):\r\n        \"\"\"Record system performance metrics\"\"\"\r\n        self.metrics['cpu_usage'].append(psutil.cpu_percent())\r\n        self.metrics['memory_usage'].append(psutil.virtual_memory().percent)\r\n\r\n    def generate_performance_report(self):\r\n        \"\"\"Generate comprehensive performance report\"\"\"\r\n        report = {\r\n            'system_performance': {\r\n                'avg_cpu_usage': statistics.mean(self.metrics['cpu_usage']) if self.metrics['cpu_usage'] else 0,\r\n                'avg_memory_usage': statistics.mean(self.metrics['memory_usage']) if self.metrics['memory_usage'] else 0,\r\n                'max_cpu_usage': max(self.metrics['cpu_usage']) if self.metrics['cpu_usage'] else 0,\r\n                'max_memory_usage': max(self.metrics['memory_usage']) if self.metrics['memory_usage'] else 0\r\n            }\r\n        }\r\n\r\n        return report\n"})}),"\n",(0,r.jsx)(t.h2,{id:"safety-testing",children:"Safety Testing"}),"\n",(0,r.jsx)(t.h3,{id:"safety-validation-tests",children:"Safety Validation Tests"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"class SafetyTester:\r\n    def __init__(self, robot_system):\r\n        self.robot_system = robot_system\r\n        self.safety_limits = {\r\n            'max_velocity': 1.0,  # m/s\r\n            'max_angular_velocity': 1.0,  # rad/s\r\n            'max_force': 50.0,  # N\r\n            'min_distance_to_human': 0.5,  # m\r\n            'max_operation_time': 3600  # seconds\r\n        }\r\n\r\n    def test_velocity_limits(self):\r\n        \"\"\"Test that robot respects velocity limits\"\"\"\r\n        # Command robot to move at high speed\r\n        cmd = Twist()\r\n        cmd.linear.x = 5.0  # Much higher than limit\r\n        cmd.angular.z = 5.0  # Much higher than limit\r\n\r\n        # Verify robot doesn't exceed limits\r\n        actual_velocity = self.robot_system.execute_command_with_monitoring(cmd)\r\n\r\n        self.assertLessEqual(actual_velocity.linear.x, self.safety_limits['max_velocity'])\r\n        self.assertLessEqual(actual_velocity.angular.z, self.safety_limits['max_angular_velocity'])\r\n\r\n    def test_collision_prevention(self):\r\n        \"\"\"Test collision prevention system\"\"\"\r\n        # Simulate obstacles in path\r\n        obstacles = [\r\n            {'position': (1.0, 0.0, 0.0), 'radius': 0.5},\r\n            {'position': (2.0, 0.0, 0.0), 'radius': 0.3}\r\n        ]\r\n\r\n        # Attempt navigation with obstacles\r\n        result = self.robot_system.navigate_with_obstacles(obstacles)\r\n\r\n        # Verify robot stopped before collision\r\n        self.assertTrue(result['stopped_safely'])\r\n        self.assertFalse(result['collision_occurred'])\r\n\r\n    def test_emergency_stop(self):\r\n        \"\"\"Test emergency stop functionality\"\"\"\r\n        # Start robot in motion\r\n        self.robot_system.start_motion()\r\n\r\n        # Trigger emergency stop\r\n        self.robot_system.trigger_emergency_stop()\r\n\r\n        # Verify robot stops within safety limits\r\n        time.sleep(0.5)  # Allow time for stop\r\n        current_state = self.robot_system.get_state()\r\n\r\n        self.assertEqual(current_state['velocity'], 0.0)\r\n        self.assertEqual(current_state['status'], 'emergency_stopped')\r\n\r\n    def test_human_detection_safety(self):\r\n        \"\"\"Test safety when humans are detected\"\"\"\r\n        # Simulate human detection\r\n        human_positions = [(2.0, 1.0, 0.0), (2.5, 1.2, 0.0)]\r\n\r\n        # Attempt navigation near humans\r\n        for pos in human_positions:\r\n            safety_check = self.robot_system.check_human_safety(pos)\r\n            self.assertGreater(safety_check['distance'], self.safety_limits['min_distance_to_human'])\r\n\r\n    def test_operation_time_limits(self):\r\n        \"\"\"Test automatic shutdown after time limits\"\"\"\r\n        start_time = time.time()\r\n\r\n        # Run robot for extended period\r\n        while time.time() - start_time < self.safety_limits['max_operation_time'] + 10:\r\n            self.robot_system.execute_command(\"continue_operation\")\r\n            time.sleep(1)\r\n\r\n        # Verify robot automatically stops\r\n        final_state = self.robot_system.get_state()\r\n        self.assertEqual(final_state['status'], 'auto_shutdown')\n"})}),"\n",(0,r.jsx)(t.h2,{id:"regression-testing",children:"Regression Testing"}),"\n",(0,r.jsx)(t.h3,{id:"automated-test-suite",children:"Automated Test Suite"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"import unittest\r\nimport xmlrunner\r\nimport subprocess\r\nimport os\r\n\r\nclass RegressionTestSuite(unittest.TestSuite):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Add all test cases\r\n        self.addTest(unittest.makeSuite(TestGeometryFunctions))\r\n        self.addTest(unittest.makeSuite(TestControlAlgorithms))\r\n        self.addTest(unittest.makeSuite(TestNavigationComponent))\r\n        self.addTest(unittest.makeSuite(TestManipulationComponent))\r\n        self.addTest(unittest.makeSuite(TestPerceptionNavigationIntegration))\r\n        self.addTest(unittest.makeSuite(TestVLAIntegration))\r\n        self.addTest(unittest.makeSuite(TestCompleteRobotSystem))\r\n\r\ndef run_regression_tests(output_dir='test_results'):\r\n    \"\"\"Run complete regression test suite\"\"\"\r\n    if not os.path.exists(output_dir):\r\n        os.makedirs(output_dir)\r\n\r\n    # Create test suite\r\n    suite = RegressionTestSuite()\r\n\r\n    # Run tests with XML output for CI/CD\r\n    with open(f'{output_dir}/test_results.xml', 'wb') as output:\r\n        runner = xmlrunner.XMLTestRunner(\r\n            output=output,\r\n            outsuffix='',\r\n            verbosity=2\r\n        )\r\n        result = runner.run(suite)\r\n\r\n    # Generate coverage report if available\r\n    try:\r\n        subprocess.run(['coverage', 'run', '-m', 'unittest', 'discover'], check=True)\r\n        subprocess.run(['coverage', 'report'], check=True)\r\n        subprocess.run(['coverage', 'html'], check=True)\r\n    except subprocess.CalledProcessError:\r\n        print(\"Coverage tools not available, skipping coverage report\")\r\n\r\n    return result\r\n\r\ndef test_continuous_integration():\r\n    \"\"\"Function to run in CI/CD pipeline\"\"\"\r\n    print(\"Starting CI/CD test pipeline...\")\r\n\r\n    # Run unit tests\r\n    unittest.main(argv=[''], exit=False, verbosity=2)\r\n\r\n    # Run integration tests\r\n    result = run_regression_tests()\r\n\r\n    # Check if tests passed\r\n    if result.wasSuccessful():\r\n        print(\"All tests passed! \u2705\")\r\n        return True\r\n    else:\r\n        print(\"Some tests failed! \u274c\")\r\n        print(f\"Failures: {len(result.failures)}\")\r\n        print(f\"Errors: {len(result.errors)}\")\r\n        return False\n"})}),"\n",(0,r.jsx)(t.h2,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,r.jsx)(t.h3,{id:"test-organization-and-management",children:"Test Organization and Management"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"# test_config.py\r\nTEST_CONFIG = {\r\n    'default_timeout': 30.0,\r\n    'simulation_timeout_multiplier': 2.0,\r\n    'retries_on_failure': 3,\r\n    'parallel_test_workers': 4,\r\n    'test_data_dir': 'test_data',\r\n    'results_dir': 'test_results',\r\n    'coverage_threshold': 80.0,  # Percent\r\n    'performance_thresholds': {\r\n        'response_time_ms': 100,\r\n        'throughput_hz': 10,\r\n        'cpu_usage_percent': 80,\r\n        'memory_usage_mb': 1024\r\n    }\r\n}\r\n\r\n# test_decorators.py\r\nimport functools\r\nimport time\r\nimport unittest\r\n\r\ndef retry_on_failure(max_attempts=3, delay=1.0):\r\n    \"\"\"Decorator to retry test on failure\"\"\"\r\n    def decorator(test_func):\r\n        @functools.wraps(test_func)\r\n        def wrapper(*args, **kwargs):\r\n            last_exception = None\r\n\r\n            for attempt in range(max_attempts):\r\n                try:\r\n                    return test_func(*args, **kwargs)\r\n                except Exception as e:\r\n                    last_exception = e\r\n                    if attempt < max_attempts - 1:\r\n                        time.sleep(delay)\r\n                    else:\r\n                        raise e\r\n\r\n        return wrapper\r\n    return decorator\r\n\r\ndef performance_test(expected_duration):\r\n    \"\"\"Decorator to test performance requirements\"\"\"\r\n    def decorator(test_func):\r\n        @functools.wraps(test_func)\r\n        def wrapper(*args, **kwargs):\r\n            start_time = time.time()\r\n            result = test_func(*args, **kwargs)\r\n            end_time = time.time()\r\n\r\n            actual_duration = end_time - start_time\r\n\r\n            if actual_duration > expected_duration:\r\n                raise AssertionError(\r\n                    f\"Test took {actual_duration:.2f}s, \"\r\n                    f\"expected < {expected_duration}s\"\r\n                )\r\n\r\n            return result\r\n        return wrapper\r\n    return decorator\r\n\r\n# Example usage\r\nclass TestWithDecorators(unittest.TestCase):\r\n    @retry_on_failure(max_attempts=3, delay=0.5)\r\n    def test_unreliable_connection(self):\r\n        \"\"\"Test that might fail due to network issues\"\"\"\r\n        # Implementation that might be flaky\r\n        pass\r\n\r\n    @performance_test(expected_duration=0.1)  # 100ms\r\n    def test_fast_algorithm(self):\r\n        \"\"\"Test that must complete quickly\"\"\"\r\n        # Implementation that should be fast\r\n        pass\n"})}),"\n",(0,r.jsx)(t.h2,{id:"continuous-testing",children:"Continuous Testing"}),"\n",(0,r.jsx)(t.h3,{id:"automated-testing-pipeline",children:"Automated Testing Pipeline"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"class ContinuousTestingPipeline:\r\n    def __init__(self):\r\n        self.test_suites = {\r\n            'unit': unittest.TestSuite(),\r\n            'integration': unittest.TestSuite(),\r\n            'system': unittest.TestSuite(),\r\n            'performance': unittest.TestSuite()\r\n        }\r\n        self.results_history = []\r\n\r\n    def add_test_suite(self, level, suite):\r\n        \"\"\"Add test suite for specific level\"\"\"\r\n        if level in self.test_suites:\r\n            self.test_suites[level].addTest(suite)\r\n\r\n    def run_all_tests(self):\r\n        \"\"\"Run all test suites in order\"\"\"\r\n        results = {}\r\n\r\n        for level, suite in self.test_suites.items():\r\n            if suite.countTestCases() > 0:\r\n                print(f\"Running {level} tests...\")\r\n                result = unittest.TextTestRunner(verbosity=1).run(suite)\r\n                results[level] = result\r\n\r\n                # Store result for history\r\n                self.results_history.append({\r\n                    'timestamp': time.time(),\r\n                    'level': level,\r\n                    'result': result\r\n                })\r\n\r\n        return results\r\n\r\n    def check_regression(self):\r\n        \"\"\"Check for test regressions\"\"\"\r\n        if len(self.results_history) < 2:\r\n            return False  # Need at least 2 runs to compare\r\n\r\n        # Compare latest run with previous run\r\n        latest = self.results_history[-1]\r\n        previous = self.results_history[-2]\r\n\r\n        # Check if success rate decreased\r\n        latest_success_rate = self.calculate_success_rate(latest['result'])\r\n        previous_success_rate = self.calculate_success_rate(previous['result'])\r\n\r\n        return latest_success_rate < previous_success_rate\r\n\r\n    def calculate_success_rate(self, result):\r\n        \"\"\"Calculate test success rate\"\"\"\r\n        total = result.testsRun\r\n        if total == 0:\r\n            return 1.0  # If no tests, consider 100% success\r\n\r\n        failed = len(result.failures)\r\n        errors = len(result.errors)\r\n        unsuccessful = failed + errors\r\n\r\n        return (total - unsuccessful) / total\r\n\r\n    def generate_test_report(self):\r\n        \"\"\"Generate comprehensive test report\"\"\"\r\n        report = {\r\n            'timestamp': time.time(),\r\n            'total_tests_run': 0,\r\n            'total_successes': 0,\r\n            'total_failures': 0,\r\n            'total_errors': 0,\r\n            'success_rate': 0.0,\r\n            'regression_detected': self.check_regression(),\r\n            'suite_results': {}\r\n        }\r\n\r\n        for level, result in self.run_all_tests().items():\r\n            report['suite_results'][level] = {\r\n                'tests_run': result.testsRun,\r\n                'failures': len(result.failures),\r\n                'errors': len(result.errors),\r\n                'success_rate': self.calculate_success_rate(result)\r\n            }\r\n            report['total_tests_run'] += result.testsRun\r\n            report['total_failures'] += len(result.failures)\r\n            report['total_errors'] += len(result.errors)\r\n\r\n        successful_tests = report['total_tests_run'] - report['total_failures'] - report['total_errors']\r\n        report['total_successes'] = successful_tests\r\n        report['success_rate'] = successful_tests / report['total_tests_run'] if report['total_tests_run'] > 0 else 0\r\n\r\n        return report\n"})}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(t.p,{children:["Continue to ",(0,r.jsx)(t.a,{href:"/humanoid-robotics-book/capstone/troubleshooting",children:"Troubleshooting"})," to learn about identifying and resolving issues in your integrated humanoid robot system."]})]})}function m(e={}){const{wrapper:t}={...(0,n.RP)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);