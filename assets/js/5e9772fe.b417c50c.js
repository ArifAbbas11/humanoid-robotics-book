"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[4901],{1817:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});var s=e(4848),o=e(8453);const a={},r="Localization for Humanoid Robots",t={id:"ai-navigation/localization",title:"Localization for Humanoid Robots",description:"Overview",source:"@site/docs/ai-navigation/localization.md",sourceDirName:"ai-navigation",slug:"/ai-navigation/localization",permalink:"/humanoid-robotics-book/ai-navigation/localization",draft:!1,unlisted:!1,editUrl:"https://github.com/ArifAbbas11/humanoid-robotics-book/tree/main/docs/ai-navigation/localization.md",tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Localization Challenges in Humanoid Robots",id:"localization-challenges-in-humanoid-robots",level:2},{value:"Sensor Movement and Vibration",id:"sensor-movement-and-vibration",level:3},{value:"Dynamic Balance Effects",id:"dynamic-balance-effects",level:3},{value:"Localization Approaches",id:"localization-approaches",level:2},{value:"Particle Filter (Monte Carlo Localization)",id:"particle-filter-monte-carlo-localization",level:3},{value:"Extended Kalman Filter (EKF)",id:"extended-kalman-filter-ekf",level:3},{value:"Visual-Inertial Odometry (VIO)",id:"visual-inertial-odometry-vio",level:3},{value:"Sensor Integration for Localization",id:"sensor-integration-for-localization",level:2},{value:"IMU Integration",id:"imu-integration",level:3},{value:"LIDAR-Based Localization",id:"lidar-based-localization",level:3},{value:"Vision-Based Localization",id:"vision-based-localization",level:3},{value:"Multi-Sensor Fusion",id:"multi-sensor-fusion",level:3},{value:"Humanoid-Specific Localization Techniques",id:"humanoid-specific-localization-techniques",level:2},{value:"Zero Moment Point (ZMP) Integration",id:"zero-moment-point-zmp-integration",level:3},{value:"Footstep-Based Localization",id:"footstep-based-localization",level:3},{value:"Kinematic Constraints",id:"kinematic-constraints",level:3},{value:"ROS 2 Localization Stack",id:"ros-2-localization-stack",level:2},{value:"Robot Localization Package",id:"robot-localization-package",level:3},{value:"Custom Localization Nodes",id:"custom-localization-nodes",level:3},{value:"Mapping Integration",id:"mapping-integration",level:2},{value:"Simultaneous Localization and Mapping (SLAM)",id:"simultaneous-localization-and-mapping-slam",level:3},{value:"Map Management",id:"map-management",level:3},{value:"Challenges and Solutions",id:"challenges-and-solutions",level:2},{value:"Drift Correction",id:"drift-correction",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:3},{value:"Robustness to Disturbances",id:"robustness-to-disturbances",level:3},{value:"Evaluation and Testing",id:"evaluation-and-testing",level:2},{value:"Accuracy Metrics",id:"accuracy-metrics",level:3},{value:"Performance Evaluation",id:"performance-evaluation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Sensor Calibration",id:"sensor-calibration",level:3},{value:"Fail-Safe Mechanisms",id:"fail-safe-mechanisms",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.RP)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"localization-for-humanoid-robots",children:"Localization for Humanoid Robots"}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"Localization is the process of determining a robot's position and orientation within an environment. For humanoid robots, localization presents unique challenges due to the dynamic nature of bipedal locomotion, sensor placement on a moving platform, and the need to maintain balance while navigating."}),"\n",(0,s.jsx)(i.h2,{id:"localization-challenges-in-humanoid-robots",children:"Localization Challenges in Humanoid Robots"}),"\n",(0,s.jsx)(i.h3,{id:"sensor-movement-and-vibration",children:"Sensor Movement and Vibration"}),"\n",(0,s.jsx)(i.p,{children:"Humanoid robots have sensors mounted on a dynamically moving platform:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Occlusions"}),": Body parts may temporarily block sensor views during walking"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Vibration"}),": Mechanical vibrations from actuators affect sensor accuracy"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Motion Blur"}),": Moving sensors can cause blurred images and distorted measurements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Sensor Position Changes"}),": Joint movements change sensor positions relative to the world"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"dynamic-balance-effects",children:"Dynamic Balance Effects"}),"\n",(0,s.jsx)(i.p,{children:"The robot's balance state affects localization:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Tilted Sensors"}),": When the robot leans, sensors may not be level"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Changing Height"}),": Robot height changes during walking cycles"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Swing Phase Errors"}),": During leg swing, the robot's center of mass shifts"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"localization-approaches",children:"Localization Approaches"}),"\n",(0,s.jsx)(i.h3,{id:"particle-filter-monte-carlo-localization",children:"Particle Filter (Monte Carlo Localization)"}),"\n",(0,s.jsx)(i.p,{children:"Particle filters are well-suited for humanoid robots due to their ability to handle uncertainty:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.stats import norm\r\n\r\nclass HumanoidParticleFilter:\r\n    def __init__(self, num_particles=1000):\r\n        self.particles = np.random.uniform(-10, 10, (num_particles, 3))  # x, y, theta\r\n        self.weights = np.ones(num_particles) / num_particles\r\n\r\n    def predict(self, control_input, dt):\r\n        """Predict particle motion based on control input"""\r\n        # Add motion model with humanoid-specific dynamics\r\n        for i in range(len(self.particles)):\r\n            # Apply control with noise\r\n            self.particles[i, 0] += control_input[\'vx\'] * dt + np.random.normal(0, 0.05)\r\n            self.particles[i, 1] += control_input[\'vy\'] * dt + np.random.normal(0, 0.05)\r\n            self.particles[i, 2] += control_input[\'omega\'] * dt + np.random.normal(0, 0.01)\r\n\r\n    def update(self, observation, map_data):\r\n        """Update particle weights based on sensor observation"""\r\n        for i in range(len(self.particles)):\r\n            predicted_obs = self.predict_sensor_reading(self.particles[i], map_data)\r\n            # Calculate likelihood of observation given prediction\r\n            likelihood = self.calculate_likelihood(observation, predicted_obs)\r\n            self.weights[i] *= likelihood\r\n\r\n    def resample(self):\r\n        """Resample particles based on weights"""\r\n        indices = np.random.choice(len(self.particles), size=len(self.particles), p=self.weights)\r\n        self.particles = self.particles[indices]\r\n        self.weights.fill(1.0 / len(self.weights))\n'})}),"\n",(0,s.jsx)(i.h3,{id:"extended-kalman-filter-ekf",children:"Extended Kalman Filter (EKF)"}),"\n",(0,s.jsx)(i.p,{children:"EKF is effective for humanoid localization when the system can be linearized:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"State Vector"}),": Position, orientation, and possibly velocities"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Process Model"}),": Humanoid kinematic model"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Measurement Model"}),": Sensor observations (landmarks, IMU, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"visual-inertial-odometry-vio",children:"Visual-Inertial Odometry (VIO)"}),"\n",(0,s.jsx)(i.p,{children:"Combines visual and inertial measurements:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Camera"}),": Provides visual features for tracking"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"IMU"}),": Provides acceleration and angular velocity"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Sensor Fusion"}),": Combines measurements for robust localization"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"sensor-integration-for-localization",children:"Sensor Integration for Localization"}),"\n",(0,s.jsx)(i.h3,{id:"imu-integration",children:"IMU Integration"}),"\n",(0,s.jsx)(i.p,{children:"Inertial Measurement Units provide crucial localization data:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Orientation"}),": Provides heading information"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Acceleration"}),": Helps estimate position changes"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Bias Estimation"}),": Correcting for sensor drift over time"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"lidar-based-localization",children:"LIDAR-Based Localization"}),"\n",(0,s.jsx)(i.p,{children:"LIDAR sensors provide accurate range measurements:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Scan Matching"}),": Aligning current scan with map"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Feature Extraction"}),": Identifying distinctive landmarks"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Loop Closure"}),": Detecting revisited locations"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"vision-based-localization",children:"Vision-Based Localization"}),"\n",(0,s.jsx)(i.p,{children:"Camera sensors enable visual localization:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Visual Odometry"}),": Tracking visual features over time"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"SLAM"}),": Simultaneous localization and mapping"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Landmark Recognition"}),": Identifying known objects or markers"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"multi-sensor-fusion",children:"Multi-Sensor Fusion"}),"\n",(0,s.jsx)(i.p,{children:"Combining multiple sensors for robust localization:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'class MultiSensorFusion:\r\n    def __init__(self):\r\n        self.imu_data = None\r\n        self.lidar_data = None\r\n        self.camera_data = None\r\n        self.odometry_data = None\r\n\r\n    def fuse_sensors(self):\r\n        """Fuse data from multiple sensors for improved localization"""\r\n        # Weighted combination of sensor data\r\n        # Higher weight to more reliable sensors\r\n        position_estimate = (\r\n            0.3 * self.imu_position +\r\n            0.4 * self.lidar_position +\r\n            0.2 * self.camera_position +\r\n            0.1 * self.odometry_position\r\n        )\r\n        return position_estimate\n'})}),"\n",(0,s.jsx)(i.h2,{id:"humanoid-specific-localization-techniques",children:"Humanoid-Specific Localization Techniques"}),"\n",(0,s.jsx)(i.h3,{id:"zero-moment-point-zmp-integration",children:"Zero Moment Point (ZMP) Integration"}),"\n",(0,s.jsx)(i.p,{children:"Using balance information for localization:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Support Polygon"}),": Tracking the area where feet contact ground"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Center of Pressure"}),": Measuring where weight is distributed"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Balance State"}),": Using balance information to constrain position estimates"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"footstep-based-localization",children:"Footstep-Based Localization"}),"\n",(0,s.jsx)(i.p,{children:"Leveraging known footstep patterns:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Step Counting"}),": Estimating distance traveled based on steps"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Foot Contact Detection"}),": Using force sensors to detect steps"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Gait Analysis"}),": Using walking pattern to improve position estimates"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"kinematic-constraints",children:"Kinematic Constraints"}),"\n",(0,s.jsx)(i.p,{children:"Using robot kinematics for localization:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Joint Angle Measurements"}),": Using encoder data for position estimation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Forward Kinematics"}),": Calculating end-effector positions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Constraint Propagation"}),": Using kinematic constraints to limit possible poses"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"ros-2-localization-stack",children:"ROS 2 Localization Stack"}),"\n",(0,s.jsx)(i.h3,{id:"robot-localization-package",children:"Robot Localization Package"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"robot_localization"})," package supports humanoid localization:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"# Example configuration for humanoid robot\r\nfrequency: 50\r\nsensor_timeout: 0.1\r\ntwo_d_mode: false\r\ntransform_time_offset: 0.0\r\ntransform_timeout: 0.0\r\nprint_diagnostics: true\r\n\r\n# Map frame to odom frame transform\r\nmap_frame: map\r\nodom_frame: odom\r\nbase_link_frame: base_link\r\nworld_frame: odom\r\n\r\n# IMU configuration\r\nimu0: imu/data\r\nimu0_config: [false, false, false,   # x, y, z\r\n              false, false, false,   # roll, pitch, yaw\r\n              true, true, true,      # x_dot, y_dot, z_dot\r\n              false, false, false,   # roll_dot, pitch_dot, yaw_dot\r\n              true, true, true,      # x_ddot, y_ddot, z_ddot\r\n              false, false, false]   # roll_ddot, pitch_ddot, yaw_ddot\r\n\r\n# Odometry configuration\r\nodom0: wheel/odometry\r\nodom0_config: [true, true, false,   # x, y, z\r\n               false, false, true,   # roll, pitch, yaw\r\n               false, false, false,  # x_dot, y_dot, z_dot\r\n               false, false, false,  # roll_dot, pitch_dot, yaw_dot\r\n               false, false, false,  # x_ddot, y_ddot, z_ddot\r\n               false, false, false]  # roll_ddot, pitch_ddot, yaw_ddot\n"})}),"\n",(0,s.jsx)(i.h3,{id:"custom-localization-nodes",children:"Custom Localization Nodes"}),"\n",(0,s.jsx)(i.p,{children:"Develop custom nodes for humanoid-specific localization:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Balance-Aware Localization"}),": Incorporating balance state into position estimates"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-Modal Localization"}),": Handling different locomotion modes"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Social Localization"}),": Considering human presence in localization"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"mapping-integration",children:"Mapping Integration"}),"\n",(0,s.jsx)(i.h3,{id:"simultaneous-localization-and-mapping-slam",children:"Simultaneous Localization and Mapping (SLAM)"}),"\n",(0,s.jsx)(i.p,{children:"SLAM is particularly important for humanoid robots:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Occupancy Grids"}),": Creating 2D maps of traversable areas"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"3D Mapping"}),": Creating detailed 3D representations for complex environments"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Semantic Mapping"}),": Adding object and room labels to maps"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"map-management",children:"Map Management"}),"\n",(0,s.jsx)(i.p,{children:"Managing maps for humanoid navigation:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-Level Maps"}),": Different resolution maps for different purposes"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Dynamic Map Updates"}),": Updating maps as environment changes"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Map Merging"}),": Combining maps from multiple sessions"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"challenges-and-solutions",children:"Challenges and Solutions"}),"\n",(0,s.jsx)(i.h3,{id:"drift-correction",children:"Drift Correction"}),"\n",(0,s.jsx)(i.p,{children:"Addressing localization drift over time:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Loop Closure"}),": Detecting when returning to known locations"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Landmark Recognition"}),": Using known landmarks for correction"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Map Matching"}),": Aligning current observations with stored maps"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"computational-efficiency",children:"Computational Efficiency"}),"\n",(0,s.jsx)(i.p,{children:"Managing computational requirements:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Approximate Methods"}),": Using efficient approximations when exact solutions are too slow"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-Resolution Processing"}),": Processing data at different resolutions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parallel Processing"}),": Using multiple cores for sensor processing"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"robustness-to-disturbances",children:"Robustness to Disturbances"}),"\n",(0,s.jsx)(i.p,{children:"Handling environmental disturbances:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Dynamic Obstacles"}),": Accounting for moving objects in the environment"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Lighting Changes"}),": Adapting to changing illumination conditions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Environmental Changes"}),": Handling changes in the environment over time"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"evaluation-and-testing",children:"Evaluation and Testing"}),"\n",(0,s.jsx)(i.h3,{id:"accuracy-metrics",children:"Accuracy Metrics"}),"\n",(0,s.jsx)(i.p,{children:"Measuring localization accuracy:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Position Error"}),": Difference between estimated and true position"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Orientation Error"}),": Difference between estimated and true orientation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Consistency"}),": How well uncertainty estimates match actual errors"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"performance-evaluation",children:"Performance Evaluation"}),"\n",(0,s.jsx)(i.p,{children:"Testing localization performance:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Real-time Performance"}),": Ensuring localization runs at required frequency"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Robustness Testing"}),": Testing under various environmental conditions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Long-term Stability"}),": Testing over extended operation periods"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(i.h3,{id:"sensor-calibration",children:"Sensor Calibration"}),"\n",(0,s.jsx)(i.p,{children:"Proper calibration is crucial:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Extrinsic Calibration"}),": Calibrating sensor positions and orientations"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Intrinsic Calibration"}),": Calibrating internal sensor parameters"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Temporal Calibration"}),": Synchronizing sensor timestamps"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"fail-safe-mechanisms",children:"Fail-Safe Mechanisms"}),"\n",(0,s.jsx)(i.p,{children:"Implementing safety measures:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Localization Quality Monitoring"}),": Detecting when localization is unreliable"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Fallback Strategies"}),": Alternative navigation methods when localization fails"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Emergency Stop"}),": Mechanisms to stop robot when localization is lost"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(i.p,{children:["Continue to ",(0,s.jsx)(i.a,{href:"/humanoid-robotics-book/ai-navigation/mapping",children:"Mapping"})," to learn about creating environmental maps for navigation."]})]})}function h(n={}){const{wrapper:i}={...(0,o.RP)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{RP:()=>a});var s=e(6540);const o=s.createContext({});function a(n){const i=s.useContext(o);return s.useMemo(()=>"function"==typeof n?n(i):{...i,...n},[i,n])}}}]);