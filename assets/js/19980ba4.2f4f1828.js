"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[1431],{3139:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=i(4848),s=i(8453);const a={},o="Sensor Configuration",l={id:"simulation/sensor-configuration",title:"Sensor Configuration",description:"Overview",source:"@site/docs/simulation/sensor-configuration.md",sourceDirName:"simulation",slug:"/simulation/sensor-configuration",permalink:"/humanoid-robotics-book/simulation/sensor-configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/ArifAbbas11/humanoid-robotics-book/tree/main/docs/simulation/sensor-configuration.md",tags:[],version:"current",frontMatter:{},sidebar:"bookSidebar",previous:{title:"Sensors in Robotics Simulation",permalink:"/humanoid-robotics-book/simulation/sensors"},next:{title:"Mini-Project: Configuring Sensors for a Humanoid Robot",permalink:"/humanoid-robotics-book/simulation/mini-project"}},t={},c=[{value:"Overview",id:"overview",level:2},{value:"URDF Sensor Definitions",id:"urdf-sensor-definitions",level:2},{value:"Adding a Camera to URDF",id:"adding-a-camera-to-urdf",level:3},{value:"Adding LIDAR to URDF",id:"adding-lidar-to-urdf",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:2},{value:"Camera Configuration",id:"camera-configuration",level:3},{value:"LIDAR Configuration",id:"lidar-configuration",level:3},{value:"IMU Configuration",id:"imu-configuration",level:3},{value:"Coordinate Frames",id:"coordinate-frames",level:2},{value:"TF Tree Setup",id:"tf-tree-setup",level:3},{value:"Frame Conventions",id:"frame-conventions",level:3},{value:"ROS 2 Message Types",id:"ros-2-message-types",level:2},{value:"Sensor Data Topics",id:"sensor-data-topics",level:3},{value:"Sensor Calibration",id:"sensor-calibration",level:2},{value:"Intrinsic Calibration",id:"intrinsic-calibration",level:3},{value:"Extrinsic Calibration",id:"extrinsic-calibration",level:3},{value:"Configuration Best Practices",id:"configuration-best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Accuracy Considerations",id:"accuracy-considerations",level:3},{value:"Validation",id:"validation",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.RP)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"sensor-configuration",children:"Sensor Configuration"}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"Proper sensor configuration is essential for accurate robot perception in simulation. This section covers how to configure various sensors on your robot model to match real-world specifications and requirements."}),"\n",(0,r.jsx)(e.h2,{id:"urdf-sensor-definitions",children:"URDF Sensor Definitions"}),"\n",(0,r.jsx)(e.h3,{id:"adding-a-camera-to-urdf",children:"Adding a Camera to URDF"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<link name="camera_link">\r\n  <visual>\r\n    <geometry>\r\n      <box size="0.05 0.05 0.05"/>\r\n    </geometry>\r\n  </visual>\r\n  <collision>\r\n    <geometry>\r\n      <box size="0.05 0.05 0.05"/>\r\n    </geometry>\r\n  </collision>\r\n  <inertial>\r\n    <mass value="0.1"/>\r\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\r\n  </inertial>\r\n</link>\r\n\r\n<joint name="camera_joint" type="fixed">\r\n  <parent link="base_link"/>\r\n  <child link="camera_link"/>\r\n  <origin xyz="0.1 0 0.1" rpy="0 0 0"/>\r\n</joint>\r\n\r\n<gazebo reference="camera_link">\r\n  <sensor type="camera" name="camera1">\r\n    <update_rate>30.0</update_rate>\r\n    <camera name="head">\r\n      <horizontal_fov>1.3962634</horizontal_fov>\r\n      <image>\r\n        <width>800</width>\r\n        <height>600</height>\r\n        <format>R8G8B8</format>\r\n      </image>\r\n      <clip>\r\n        <near>0.02</near>\r\n        <far>300</far>\r\n      </clip>\r\n      <noise>\r\n        <type>gaussian</type>\r\n        <mean>0.0</mean>\r\n        <stddev>0.007</stddev>\r\n      </noise>\r\n    </camera>\r\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\r\n      <frame_name>camera_optical_frame</frame_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"adding-lidar-to-urdf",children:"Adding LIDAR to URDF"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<link name="lidar_link">\r\n  <visual>\r\n    <geometry>\r\n      <cylinder radius="0.05" length="0.05"/>\r\n    </geometry>\r\n  </visual>\r\n  <collision>\r\n    <geometry>\r\n      <cylinder radius="0.05" length="0.05"/>\r\n    </geometry>\r\n  </collision>\r\n  <inertial>\r\n    <mass value="0.2"/>\r\n    <inertia ixx="0.0002" ixy="0" ixz="0" iyy="0.0002" iyz="0" izz="0.0001"/>\r\n  </inertial>\r\n</link>\r\n\r\n<joint name="lidar_joint" type="fixed">\r\n  <parent link="base_link"/>\r\n  <child link="lidar_link"/>\r\n  <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n</joint>\r\n\r\n<gazebo reference="lidar_link">\r\n  <sensor type="ray" name="lidar_sensor">\r\n    <pose>0 0 0 0 0 0</pose>\r\n    <visualize>true</visualize>\r\n    <update_rate>10</update_rate>\r\n    <ray>\r\n      <scan>\r\n        <horizontal>\r\n          <samples>720</samples>\r\n          <resolution>1</resolution>\r\n          <min_angle>-3.14159</min_angle>\r\n          <max_angle>3.14159</max_angle>\r\n        </horizontal>\r\n      </scan>\r\n      <range>\r\n        <min>0.10</min>\r\n        <max>30.0</max>\r\n        <resolution>0.01</resolution>\r\n      </range>\r\n      <noise>\r\n        <type>gaussian</type>\r\n        <mean>0.0</mean>\r\n        <stddev>0.01</stddev>\r\n      </noise>\r\n    </ray>\r\n    <plugin name="lidar_controller" filename="libgazebo_ros_laser.so">\r\n      <topic_name>scan</topic_name>\r\n      <frame_name>lidar_link</frame_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,r.jsx)(e.h3,{id:"camera-configuration",children:"Camera Configuration"}),"\n",(0,r.jsx)(e.p,{children:"Key parameters for camera sensors:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Resolution"}),": Image width and height in pixels"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Field of View"}),": Horizontal and vertical viewing angles"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Frame Rate"}),": Updates per second (Hz)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Image Format"}),": Color space (RGB8, RGBA8, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"lidar-configuration",children:"LIDAR Configuration"}),"\n",(0,r.jsx)(e.p,{children:"Important LIDAR parameters:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Range"}),": Minimum and maximum detection distance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Angular Resolution"}),": Angle between consecutive measurements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Scan Frequency"}),": How often the scan is updated"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Number of Rays"}),": Samples in horizontal plane"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"imu-configuration",children:"IMU Configuration"}),"\n",(0,r.jsx)(e.p,{children:"IMU sensor parameters:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Update Rate"}),": Frequency of measurements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Noise Characteristics"}),": Bias, drift, and random noise"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Measurement Range"}),": Maximum detectable values"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"coordinate-frames",children:"Coordinate Frames"}),"\n",(0,r.jsx)(e.h3,{id:"tf-tree-setup",children:"TF Tree Setup"}),"\n",(0,r.jsx)(e.p,{children:"Sensors require proper coordinate frame definitions:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Define optical frames for cameras --\x3e\r\n<joint name="camera_optical_joint" type="fixed">\r\n  <parent link="camera_link"/>\r\n  <child link="camera_optical_frame"/>\r\n  <origin xyz="0 0 0" rpy="-1.570796 0 -1.570796"/>\r\n</joint>\r\n\r\n<link name="camera_optical_frame"/>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"frame-conventions",children:"Frame Conventions"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Camera Frames"}),": Optical axis along +Z, X along image width, Y along image height"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"IMU Frames"}),": Typically aligned with robot body frame"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"LIDAR Frames"}),": Usually Z-axis up, X-forward"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"ros-2-message-types",children:"ROS 2 Message Types"}),"\n",(0,r.jsx)(e.h3,{id:"sensor-data-topics",children:"Sensor Data Topics"}),"\n",(0,r.jsx)(e.p,{children:"Common ROS 2 message types for sensors:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cameras"}),": ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/Image"})," and ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/CameraInfo"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"LIDAR"}),": ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/LaserScan"})," or ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/PointCloud2"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"IMU"}),": ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/Imu"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint States"}),": ",(0,r.jsx)(e.code,{children:"sensor_msgs/msg/JointState"})]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"sensor-calibration",children:"Sensor Calibration"}),"\n",(0,r.jsx)(e.h3,{id:"intrinsic-calibration",children:"Intrinsic Calibration"}),"\n",(0,r.jsx)(e.p,{children:"Camera intrinsic parameters:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:"camera_matrix:\r\n  rows: 3\r\n  cols: 3\r\n  data: [fx, 0, cx, 0, fy, cy, 0, 0, 1]\r\ndistortion_coefficients:\r\n  rows: 1\r\n  cols: 5\r\n  data: [k1, k2, p1, p2, k3]\n"})}),"\n",(0,r.jsx)(e.h3,{id:"extrinsic-calibration",children:"Extrinsic Calibration"}),"\n",(0,r.jsx)(e.p,{children:"Relationship between sensor and robot frames:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:"# Transform between base_link and camera_link\r\ntranslation: [0.1, 0.0, 0.1]\r\nrotation: [0.0, 0.0, 0.0, 1.0]  # quaternion (x, y, z, w)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"configuration-best-practices",children:"Configuration Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Reduce sensor resolution if computational resources are limited"}),"\n",(0,r.jsx)(e.li,{children:"Lower update rates for less time-critical sensors"}),"\n",(0,r.jsx)(e.li,{children:"Use approximate filters for sensor fusion when precision isn't critical"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"accuracy-considerations",children:"Accuracy Considerations"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Match simulation parameters to real sensor specifications"}),"\n",(0,r.jsx)(e.li,{children:"Include realistic noise models based on datasheets"}),"\n",(0,r.jsx)(e.li,{children:"Calibrate transforms between sensors and robot frames"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"validation",children:"Validation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Compare simulated sensor data with real sensor outputs"}),"\n",(0,r.jsx)(e.li,{children:"Verify coordinate frame relationships"}),"\n",(0,r.jsx)(e.li,{children:"Test edge cases and boundary conditions"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Missing TF transforms"}),": Ensure all sensor frames are properly connected"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Incorrect coordinate frames"}),": Verify orientation and position of sensors"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance problems"}),": Reduce sensor fidelity if needed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Data quality"}),": Check noise parameters and range limits"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(e.p,{children:["Continue to ",(0,r.jsx)(e.a,{href:"/humanoid-robotics-book/simulation/mini-project",children:"Mini-Project"})," to apply sensor configuration concepts."]})]})}function m(n={}){const{wrapper:e}={...(0,s.RP)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{RP:()=>a});var r=i(6540);const s=r.createContext({});function a(n){const e=r.useContext(s);return r.useMemo(()=>"function"==typeof n?n(e):{...e,...n},[e,n])}}}]);