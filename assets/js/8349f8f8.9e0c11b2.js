"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[7929],{5648:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=i(4848),r=i(8453);const a={},l="Mapping for Humanoid Robot Navigation",o={id:"ai-navigation/mapping",title:"Mapping for Humanoid Robot Navigation",description:"Overview",source:"@site/docs/ai-navigation/mapping.md",sourceDirName:"ai-navigation",slug:"/ai-navigation/mapping",permalink:"/humanoid-robotics-book/ai-navigation/mapping",draft:!1,unlisted:!1,editUrl:"https://github.com/ArifAbbas11/humanoid-robotics-book/tree/main/docs/ai-navigation/mapping.md",tags:[],version:"current",frontMatter:{}},t={},c=[{value:"Overview",id:"overview",level:2},{value:"Types of Maps",id:"types-of-maps",level:2},{value:"2D Occupancy Grid Maps",id:"2d-occupancy-grid-maps",level:3},{value:"3D Volumetric Maps",id:"3d-volumetric-maps",level:3},{value:"Semantic Maps",id:"semantic-maps",level:3},{value:"Humanoid-Specific Mapping Considerations",id:"humanoid-specific-mapping-considerations",level:2},{value:"Multi-Level Mapping",id:"multi-level-mapping",level:3},{value:"Height-Aware Mapping",id:"height-aware-mapping",level:3},{value:"Traversability Analysis",id:"traversability-analysis",level:3},{value:"Mapping Algorithms",id:"mapping-algorithms",level:2},{value:"Occupancy Grid Mapping",id:"occupancy-grid-mapping",level:3},{value:"3D Mapping",id:"3d-mapping",level:3},{value:"SLAM (Simultaneous Localization and Mapping)",id:"slam-simultaneous-localization-and-mapping",level:3},{value:"Sensor Integration for Mapping",id:"sensor-integration-for-mapping",level:2},{value:"LIDAR Mapping",id:"lidar-mapping",level:3},{value:"Visual Mapping",id:"visual-mapping",level:3},{value:"Multi-Sensor Mapping",id:"multi-sensor-mapping",level:3},{value:"ROS 2 Mapping Tools",id:"ros-2-mapping-tools",level:2},{value:"Navigation2 Map Server",id:"navigation2-map-server",level:3},{value:"Cartographer",id:"cartographer",level:3},{value:"Custom Mapping Nodes",id:"custom-mapping-nodes",level:3},{value:"Mapping Challenges",id:"mapping-challenges",level:2},{value:"Dynamic Environments",id:"dynamic-environments",level:3},{value:"Large-Scale Mapping",id:"large-scale-mapping",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:3},{value:"Semantic Mapping",id:"semantic-mapping",level:2},{value:"Object Recognition Integration",id:"object-recognition-integration",level:3},{value:"Functional Area Mapping",id:"functional-area-mapping",level:3},{value:"Quality Assessment",id:"quality-assessment",level:2},{value:"Map Accuracy",id:"map-accuracy",level:3},{value:"Map Validation",id:"map-validation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Map Management",id:"map-management",level:3},{value:"Sensor Configuration",id:"sensor-configuration",level:3},{value:"Incremental Mapping",id:"incremental-mapping",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.RP)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"mapping-for-humanoid-robot-navigation",children:"Mapping for Humanoid Robot Navigation"}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"Mapping is the process of creating a representation of the environment that can be used for navigation. For humanoid robots, mapping must account for the robot's unique characteristics such as height, balance requirements, and the need to navigate complex 3D environments with stairs, ramps, and other obstacles that wheeled robots don't encounter."}),"\n",(0,s.jsx)(e.h2,{id:"types-of-maps",children:"Types of Maps"}),"\n",(0,s.jsx)(e.h3,{id:"2d-occupancy-grid-maps",children:"2D Occupancy Grid Maps"}),"\n",(0,s.jsx)(e.p,{children:"Occupancy grid maps divide the environment into discrete cells:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Binary Representation"}),": Each cell is either occupied or free"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Probabilistic"}),": Each cell has a probability of occupancy"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Resolution"}),": Grid cell size affects map detail and computational requirements"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"3d-volumetric-maps",children:"3D Volumetric Maps"}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robots, 3D maps are often necessary:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Voxel Grids"}),": 3D grid-based representation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Point Clouds"}),": Dense 3D point representation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mesh Maps"}),": Surface-based 3D representation"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"semantic-maps",children:"Semantic Maps"}),"\n",(0,s.jsx)(e.p,{children:"Adding semantic information to geometric maps:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Object Labels"}),": Identifying doors, furniture, stairs"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Functional Areas"}),": Rooms, corridors, obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Traversability"}),": Distinguishing walkable from non-walkable areas"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"humanoid-specific-mapping-considerations",children:"Humanoid-Specific Mapping Considerations"}),"\n",(0,s.jsx)(e.h3,{id:"multi-level-mapping",children:"Multi-Level Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots need maps that account for vertical navigation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stair Detection"}),": Identifying and mapping stairs for navigation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Ramp Mapping"}),": Recognizing gradual elevation changes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-story Maps"}),": Connecting maps across different floors"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"height-aware-mapping",children:"Height-Aware Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Accounting for the robot's height and reach:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Clearance Mapping"}),": Ensuring sufficient headroom"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Step Height Detection"}),": Identifying obstacles that affect walking"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reachable Areas"}),": Mapping areas accessible to the robot"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"traversability-analysis",children:"Traversability Analysis"}),"\n",(0,s.jsx)(e.p,{children:"Determining which areas are safe for humanoid navigation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Surface Stability"}),": Identifying uneven or slippery surfaces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Obstacle Height"}),": Distinguishing obstacles that can be stepped over"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Narrow Passages"}),": Ensuring sufficient width for bipedal locomotion"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"mapping-algorithms",children:"Mapping Algorithms"}),"\n",(0,s.jsx)(e.h3,{id:"occupancy-grid-mapping",children:"Occupancy Grid Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Basic algorithm for creating 2D occupancy maps:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.ndimage import binary_dilation\r\n\r\nclass OccupancyGridMap:\r\n    def __init__(self, width, height, resolution):\r\n        self.resolution = resolution\r\n        self.width = width\r\n        self.height = height\r\n        self.grid = np.zeros((height, width))  # -1: unknown, 0: free, 1: occupied\r\n        self.log_odds = np.zeros((height, width))  # Log odds representation\r\n        self.log_odds_free = np.log(0.3 / 0.7)  # Log odds for free space\r\n        self.log_odds_occupied = np.log(0.9 / 0.1)  # Log odds for occupied space\r\n\r\n    def update_cell(self, x, y, occupied):\r\n        """Update a single cell based on sensor reading"""\r\n        if 0 <= x < self.width and 0 <= y < self.height:\r\n            if occupied:\r\n                self.log_odds[y, x] += self.log_odds_occupied\r\n            else:\r\n                self.log_odds[y, x] += self.log_odds_free\r\n\r\n            # Convert back to probability\r\n            prob = 1 - 1 / (1 + np.exp(self.log_odds[y, x]))\r\n            if prob > 0.7:\r\n                self.grid[y, x] = 1  # occupied\r\n            elif prob < 0.3:\r\n                self.grid[y, x] = 0  # free\r\n            else:\r\n                self.grid[y, x] = -1  # unknown\r\n\r\n    def ray_trace(self, start, end, occupied_end):\r\n        """Perform ray tracing from sensor reading"""\r\n        # Bresenham\'s line algorithm for ray tracing\r\n        x0, y0 = int(start[0] / self.resolution), int(start[1] / self.resolution)\r\n        x1, y1 = int(end[0] / self.resolution), int(end[1] / self.resolution)\r\n\r\n        dx = abs(x1 - x0)\r\n        dy = abs(y1 - y0)\r\n        sx = 1 if x0 < x1 else -1\r\n        sy = 1 if y0 < y1 else -1\r\n        err = dx - dy\r\n\r\n        # Mark endpoint as occupied or free\r\n        if occupied_end:\r\n            self.update_cell(x1, y1, True)\r\n        else:\r\n            self.update_cell(x1, y1, False)\r\n\r\n        # Mark free space along the ray\r\n        x, y = x0, y0\r\n        while x != x1 or y != y1:\r\n            if 0 <= x < self.width and 0 <= y < self.height:\r\n                self.update_cell(x, y, False)\r\n            e2 = 2 * err\r\n            if e2 > -dy:\r\n                err -= dy\r\n                x += sx\r\n            if e2 < dx:\r\n                err += dx\r\n                y += sy\n'})}),"\n",(0,s.jsx)(e.h3,{id:"3d-mapping",children:"3D Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Extending mapping to three dimensions:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"OctoMap"}),": Hierarchical 3D occupancy mapping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"TSDF (Truncated Signed Distance Function)"}),": Surface reconstruction"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Point Cloud Integration"}),": Combining multiple point cloud observations"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"slam-simultaneous-localization-and-mapping",children:"SLAM (Simultaneous Localization and Mapping)"}),"\n",(0,s.jsx)(e.p,{children:"SLAM algorithms perform mapping and localization simultaneously:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Graph-Based SLAM"}),": Optimization-based approach"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Filter-Based SLAM"}),": Recursive Bayesian estimation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Keyframe-Based SLAM"}),": Using key poses for efficiency"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"sensor-integration-for-mapping",children:"Sensor Integration for Mapping"}),"\n",(0,s.jsx)(e.h3,{id:"lidar-mapping",children:"LIDAR Mapping"}),"\n",(0,s.jsx)(e.p,{children:"LIDAR provides accurate range measurements:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Scan Registration"}),": Aligning scans using odometry or IMU"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Loop Closure"}),": Detecting revisited locations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-Beam LIDAR"}),": Handling 3D LIDAR data"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"visual-mapping",children:"Visual Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Camera-based mapping techniques:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual SLAM"}),": Feature-based mapping using cameras"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Direct Methods"}),": Using pixel intensities instead of features"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Structure from Motion"}),": Reconstructing 3D structure from multiple views"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"multi-sensor-mapping",children:"Multi-Sensor Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Combining multiple sensor types:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Fusion"}),": Integrating data from different sensors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complementary Sensors"}),": Using different sensors for different aspects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Redundancy"}),": Multiple sensors for robust mapping"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"ros-2-mapping-tools",children:"ROS 2 Mapping Tools"}),"\n",(0,s.jsx)(e.h3,{id:"navigation2-map-server",children:"Navigation2 Map Server"}),"\n",(0,s.jsx)(e.p,{children:"The Navigation2 stack includes mapping capabilities:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# Example map server configuration\r\nmap_saver:\r\n  ros__parameters:\r\n    save_map_timeout: 5.0\r\n    free_thresh_default: 0.25\r\n    occupied_thresh_default: 0.65\r\n    map_subscribe_transient_local: True\n"})}),"\n",(0,s.jsx)(e.h3,{id:"cartographer",children:"Cartographer"}),"\n",(0,s.jsx)(e.p,{children:"Google's SLAM library integrated with ROS 2:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lua",children:'-- Example Cartographer configuration for humanoid robot\r\noptions = {\r\n  tracking_frame = "base_link",\r\n  published_frame = "odom",\r\n  map_frame = "map",\r\n  odom_frame = "odom",\r\n  provide_odom_frame = true,\r\n  use_odometry = true,\r\n  use_nav_sat = false,\r\n  use_landmarks = false,\r\n  num_laser_scans = 1,\r\n  num_multi_echo_laser_scans = 0,\r\n  num_subdivisions_per_laser_scan = 1,\r\n  num_point_clouds = 0,\r\n  lookup_transform_timeout_sec = 0.2,\r\n  submap_publish_period_sec = 0.3,\r\n  pose_publish_period_sec = 5e-03,\r\n  trajectory_publish_period_sec = 30e-03,\r\n  rangefinder_sampling_ratio = 1.,\r\n  odometry_sampling_ratio = 1.,\r\n  fixed_frame_pose_sampling_ratio = 1.,\r\n  imu_sampling_ratio = 1.,\r\n  landmarks_sampling_ratio = 1.,\r\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"custom-mapping-nodes",children:"Custom Mapping Nodes"}),"\n",(0,s.jsx)(e.p,{children:"Develop custom nodes for humanoid-specific mapping:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Height-Aware Mapping"}),": Creating maps that consider robot height"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Traversability Mapping"}),": Distinguishing walkable from non-walkable areas"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stair Mapping"}),": Specialized algorithms for stair detection and mapping"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"mapping-challenges",children:"Mapping Challenges"}),"\n",(0,s.jsx)(e.h3,{id:"dynamic-environments",children:"Dynamic Environments"}),"\n",(0,s.jsx)(e.p,{children:"Handling moving objects in the environment:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Object Filtering"}),": Removing moving objects from static maps"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Temporary Obstacles"}),": Distinguishing between permanent and temporary obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Moving Object Tracking"}),": Tracking dynamic obstacles separately"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"large-scale-mapping",children:"Large-Scale Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Managing maps of large environments:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Map Tiling"}),": Dividing large maps into smaller tiles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Memory Management"}),": Efficient storage and retrieval of map data"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Map Streaming"}),": Loading only necessary map portions"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"computational-efficiency",children:"Computational Efficiency"}),"\n",(0,s.jsx)(e.p,{children:"Balancing map quality and computational requirements:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-Resolution Maps"}),": Different detail levels for different needs"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Incremental Updates"}),": Updating only changed portions of the map"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Parallel Processing"}),": Using multiple cores for mapping operations"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"semantic-mapping",children:"Semantic Mapping"}),"\n",(0,s.jsx)(e.h3,{id:"object-recognition-integration",children:"Object Recognition Integration"}),"\n",(0,s.jsx)(e.p,{children:"Adding semantic information to geometric maps:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Deep Learning"}),": Using CNNs for object recognition"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Instance Segmentation"}),": Distinguishing individual objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Semantic Labels"}),": Associating labels with map regions"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"functional-area-mapping",children:"Functional Area Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Identifying areas with specific functions:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Room Detection"}),": Identifying and labeling rooms"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Path Planning Areas"}),": Marking corridors and open spaces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety Zones"}),": Identifying safe areas for robot operation"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"quality-assessment",children:"Quality Assessment"}),"\n",(0,s.jsx)(e.h3,{id:"map-accuracy",children:"Map Accuracy"}),"\n",(0,s.jsx)(e.p,{children:"Evaluating map quality:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Geometric Accuracy"}),": How well the map matches the real environment"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Completeness"}),": Coverage of the environment"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consistency"}),": Internal consistency of the map"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"map-validation",children:"Map Validation"}),"\n",(0,s.jsx)(e.p,{children:"Verifying map correctness:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Ground Truth Comparison"}),": Comparing with known maps when available"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Navigation Performance"}),": Testing navigation using the map"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Loop Closure Detection"}),": Verifying that loops are properly closed"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(e.h3,{id:"map-management",children:"Map Management"}),"\n",(0,s.jsx)(e.p,{children:"Effective map handling strategies:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Map Updates"}),": Regularly updating maps as the environment changes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Map Merging"}),": Combining maps from different sessions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Map Compression"}),": Efficiently storing large maps"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"sensor-configuration",children:"Sensor Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Optimal sensor setup for mapping:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Placement"}),": Positioning sensors for optimal coverage"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Fusion"}),": Combining multiple sensors for robust mapping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Calibration"}),": Properly calibrating all sensors"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"incremental-mapping",children:"Incremental Mapping"}),"\n",(0,s.jsx)(e.p,{children:"Building maps incrementally:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Local Mapping"}),": Creating local maps and combining them"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Global Optimization"}),": Periodically optimizing the entire map"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consistency Maintenance"}),": Ensuring map consistency over time"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(e.p,{children:["Continue to ",(0,s.jsx)(e.a,{href:"/humanoid-robotics-book/ai-navigation/control-systems",children:"Control Systems"})," to learn about controlling humanoid robot navigation."]})]})}function p(n={}){const{wrapper:e}={...(0,r.RP)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{RP:()=>a});var s=i(6540);const r=s.createContext({});function a(n){const e=s.useContext(r);return s.useMemo(()=>"function"==typeof n?n(e):{...e,...n},[e,n])}}}]);